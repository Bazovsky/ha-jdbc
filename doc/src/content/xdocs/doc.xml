<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V2.0//EN" "http://forrest.apache.org/dtd/document-v20.dtd">
<document>
	<header> 
		<title>Documentation</title>
	</header>
	<body>
		<section>
			<title>Requirements</title>
			<ul>
				<li>Java Runtime Environment 1.5+ (Java 1.4 supported via Retrotranslator)<a href="#Java1.4">*</a></li>
				<li>Type IV <acronym title="Java Database Connectivity">JDBC</acronym> 3.0 driver</li>
				<li>A <acronym title="Java Management Extensions">JMX</acronym> 1.2 compliant MBean server<a href="#MBeanServer">*</a></li>
				<li>All databases in a cluster must initially be in sync.</li>
			</ul>
			<section id="Java1.4">
				<title>Using Java 1.4</title>
				<p>
					As of version 1.1, the HA-JDBC codebase requires the Java 1.5 compiler.
					However, a Java 1.4 compatible distribution is generated using <a href="http://retrotranslator.sourceforge.net">Retrotranslator</a>.
					Consequently, this distribution has some additional runtime dependencies, defined <a href="#dependencies">here</a>.
				</p>
				<p>
					HA-JDBC requires a <acronym title="Java Management Extensions">JMX</acronym> 1.2+ MBean server.
					While Java 1.5 includes Sun's <acronym title="Java Management Extensions">JMX</acronym> reference implementation, Java 1.4 does not.
					Therefore, if your application server or servlet container does not include a <acronym title="Java Management Extensions">JMX</acronym> 1.2 implementation, it is up to you to supply one.
					Below is a list of popular and free <acronym title="Java Management Extensions">JMX</acronym> implementations available to you:
				</p>
				<ul>
					<li><a href="http://java.sun.com/products/JavaManagement/index.jsp">Sun's <acronym title="Java Management Extensions">JMX</acronym> Reference Implemenation</a></li>
					<li><a href="http://mx4j.sourceforge.net">MX4J</a></li>
					<li><a href="http://www.xmojo.org/products/xmojo">XMOJO</a></li>
					<li><a href="http://www.jboss.org/developers/projects/jboss/jbossmx">JBossMX</a></li>
					<li><a href="http://www.huihoo.org/jfox/jfoxmx/index.html">JFoxMX</a></li>
				</ul>
			</section>
			<section id="MBeanServer">
				<title>Creating an MBean server</title>
				<p>
					If you are using HA-JDBC outside a servlet/<acronym title="Enterprise Java Bean">EJB</acronym> container, or if you are supplying your own <acronym title="Java Management Extensions">JMX</acronym> implementation, you may need to explicitly create an MBean server.
					If this is the case, add the following code to a startup hook in your application:
				</p>
				<source>javax.management.MBeanServerFactory.createMBeanServer();</source>
			</section>
		</section>
		<section id="dependencies">
			<title>Dependencies</title>
			<p>
				HA-JDBC depencency libraries are contained in the /lib directory of the distribution:
			</p>
			<dl>
				<dt>/lib : Libraries used both for compiling and during runtime</dt>
				<dd>
					<dl>
						<dt>jgroups-XXX.jar : <a href="http://jgroups.org">JGroups</a></dt>
						<dd>Optional.  Required for distributable mode.</dd>
						<dt>jibx-run-XXX.jar : <a href="http://jibx.sourceforge.net">JiBX</a> runtime</dt>
						<dd>Required.</dd>
						<dt>quartz-XXX.jar : <a href="http://www.opensymphony.com/quartz">Quartz</a></dt>
						<dd>Optional.  Required if auto-activate-schedule and/or failure-detect-schedule cluster options are specified.</dd>
					</dl>
				</dd>
				<dt>/lib/runtime : Libraries used during runtime</dt>
				<dd>
					<dl>
						<dt>concurrent-XXX.jar : Doug Lea's <a href="http://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/intro.html">util.concurrent</a> package</dt>
						<dd>Optional.  Required dependency of JGroups.</dd>
						<dt>jcl104-over-slf4j.jar : <a href="http://slf4j.org">SLF4J</a> drop-in replacement for commons-logging-1.0.4.jar</dt>
						<dd>Optional.  Required dependency of JGroups and Quartz.  Provided for <a href="http://www.slf4j.org/manual.html#gradual">gradual migration</a> from commons-logging to SLF4J.</dd>
						<dt>slf4j-XXX-jcl.jar : Commons-logging provider for <a href="http://slf4j.org">SLF4J</a>.</dt>
						<dd>Optional.  Required if you insist on using commons-logging-XXX.jar instead of jcl104-over-slf4j.jar.</dd>
						<dt>slf4j-XXX-jdk14.jar : java.util.logging provider for <a href="http://slf4j.org">SLF4J</a>.</dt>
						<dd>Optional.  Required if java.util.logging is your logging provider.</dd>
						<dt>slf4j-XXX-log4j12.jar : Log4J 1.2.X provider for <a href="http://slf4j.org">SLF4J</a>.</dt>
						<dd>Optional.  Required if Log4J 1.2.X is your logging provider.</dd>
						<dt>slf4j-XXX-log4j13.jar : Log4J 1.3.X provider for <a href="http://slf4j.org">SLF4J</a>.</dt>
						<dd>Optional.  Required if Log4J 1.3.X is your logging provider.</dd>
						<dt>slf4j-XXX-simple.jar : Simple-Log provider for <a href="http://slf4j.org">SLF4J</a>.</dt>
						<dd>Optional.  Required if Simple-Log is your logging provider.</dd>
						<dt>stax-api-XXX.jar : Streaming API for XML</dt>
						<dd>Required.  Dependency of JiBX</dd>
						<dt>wstx-XXX.jar : Woodstox StAX implementation</dt>
						<dd>Required.  Dependency of JiBX.</dd>
					</dl>
				</dd>
				<dt>/lib/runtime-1.4 : Additional libraries used during runtime for JDK 1.4 support</dt>
				<dd>
					<dl>
						<dt>backport-util-concurrent-XXX.jar : JDK 1.4 <a href="http://dcl.mathcs.emory.edu/util/backport-util-concurrent">backport of java.util.concurrent</a> package</dt>
						<dd>Required.  Runtime dependency of Retrotranslator.</dd>
						<dt>retrotranslator-runtime-XXX.jar : <a href="http://retrotranslator.sourceforge.net">Retrotranslator</a></dt>
						<dd>Required.</dd>
					</dl>
				</dd>
				<dt>/lib/compile : Libraries used for compiling</dt>
				<dd>
					<ul>
						<li>bcel-XXX.jar : <a href="http://jakarta.apache.org/bcel">BCEL</a></li>
						<li>jibx-bind-XXX.jar : <a href="http://jibx.sourceforge.net">JiBX</a> binding compiler</li>
						<li>slf4j-XXX-nop.jar : No-op implementation of <a href="http://slf4j.org">SLF4J</a></li>
					</ul>
				</dd>
				<dt>/lib/compile-1.4 : Additional libraries used for compiling for JDK 1.4 support</dt>
				<dd>
					<ul>
						<li>retrotranslator-transformer-XXX.jar : <a href="http://retrotranslator.sourceforge.net">Retrotranslator</a> compiler</li>
					</ul>
				</dd>
				<dt>/lib/test : Libraries used for compiling and running test suite.</dt>
				<dd>
					<ul>
						<li>easymock-XXX.jar : <a href="http://easymock.org">EasyMock</a></li>
						<li>testng-XXX.jar : <a href="http://testng.org">TestNG</a></li>
					</ul>
				</dd>
			</dl>
		</section>
		<section>
			<title>&lt;ha-jdbc&gt; Configuration</title>
			<p>
				Configuration for HA-JDBC managed database clusters is contained in a single XML file.
				The algorithm used to locate the configuration file resource at runtime is as follows:
			</p>
			<ol>
				<li>
					<p>Read the resource name from the <code>ha-jdbc.configuration</code> system property.  If not defined, the default value "<code>ha-jdbc.xml</code>" is used.</p>
				</li>
				<li>
					<p>Attempt to interpret the resource name as a URL.</p>
				</li>
				<li>
					<p>If the resource name cannot be converted to a URL, then search for the resource in the classpath using the following algorithm:</p>
					<ol>
						<li>Search for resource using the thread context class loader.</li>
						<li>If not found, search for resource using the class loader of the current class.</li>
						<li>If not found, search for resource using the system class loader.</li>
					</ol>
				</li>
				<li>
					<p>If still not found, throw an exception back to the caller.</p>
				</li>
			</ol>
			<p>
				The root element of the configuration file has the following definition:
			</p>
			<source id="ha-jdbc">&lt;!ELEMENT ha-jdbc (<a href="#distributable">distributable</a>?,<a href="#sync">sync</a>+,<a href="#cluster">cluster</a>+)&gt;</source>
			<section id="distributable">
				<title>&lt;distributable&gt;</title>
				<p>
					Indicates that database clusters defined in this file will be accessed by multiple JVMs.
					HA-JDBC leverages <a href="http://www.jgroups.org">JGroups</a> to handle communication between database clusters across servers.
				</p>
				<source><![CDATA[
<!ELEMENT distributable EMPTY>
<!ATTLIST distributable
  protocol CDATA "default-minimalthreads.xml"
  timeout  CDATA "1000"
>
]]></source>
				<dl>
					<dt>config</dt>
					<dd>
						Defines one of the following:
						<ul>
							<li>Name of a system resource containing the JGroups XML configuration.</li>
							<li>URL of the JGroups XML configuration file.</li>
							<li>Path of the JGroups XML configuration on the local file system.</li>
						</ul>
						The jgroups config file is expected to use the new (as of 2.3) muliplexing format.
						See the JGroup's <a href="http://www.jboss.com/wiki/Wiki.jsp?page=JGroups">Wiki</a> for assistance with customizing the protocol stack.
					</dd>
					<dt>stack</dt>
					<dd>
						The stack name from the jgroups configuration file.
					</dd>
					<dt>timeout</dt>
					<dd>
						Indicates the number of milliseconds allowed for JGroups operations.
					</dd>
				</dl>
			</section>
			<section id="sync">
				<title>&lt;sync&gt;</title>
				<p>
					Defines a strategy for synchronizing a database before activation.
					If the strategy contains JavaBean properties, you can override their default values.
				</p>
				<source>&lt;!ELEMENT sync (<a href="#property">property</a>*)&gt;</source>
				<source><![CDATA[
<!ATTLIST sync
  id    ID    #REQUIRED
  class CDATA #REQUIRED
>
				]]></source>
				<dl>
					<dt>id</dt>
					<dd>
						Uniquely identifies this synchronization strategy.  Used when invoking activation commands.
					</dd>
					<dt>class</dt>
					<dd>
						Class name of an implementation of the <a href="api/net/sf/hajdbc/SynchronizationStrategy.html">net.sf.hajdbc.SynchronizationStrategy</a> interface.
						Details <a href="#sync-strategies">here</a>.
					</dd>
				</dl>
				<section id="property">
					<title>&lt;property&gt;</title>
					<source><![CDATA[
<!ELEMENT property (#PCDATA)>
<!ATTLIST property
  name CDATA #REQUIRED
>
]]></source>
					<dl>
						<dt>name</dt>
						<dd>
							The name of the property.
							The value of the property is defined inside this element's contents.
						</dd>
					</dl>
				</section>
			</section>
			<section id="cluster">
				<title>&lt;cluster&gt;</title>
				<p>
					Defines the nodes and behavior of a database cluster.
				</p>
				<source>&lt;!ELEMENT cluster (<a href="#database">database</a>+|<a href="#datasource">datasource</a>+)&gt;</source>
				<p>
					An HA-JDBC database cluster is accessed in one of two ways: either via the <code>java.sql.DriverManager</code>, or via a <code>javax.sql.DataSource</code>.
				</p>
				<source><![CDATA[
<!ATTLIST cluster
  id                      CDATA                            #REQUIRED
  balancer                (simple|random|round-robin|load) #REQUIRED
  default-sync            IDREF                            #REQUIRED
  dialect                 CDATA                            "net.sf.hajdbc.dialect.DefaultDialect"
  meta-data-cache         (none|lazy|eager)                #REQUIRED
  transactions            (local|xa)                       #REQUIRED
  auto-activate-schedule  CDATA                            #IMPLIED
  failure-detect-schedule CDATA                            #IMPLIED
  min-threads             CDATA                            "0"
  max-threads             CDATA                            "100"
  max-idle                CDATA                            "60"
>
]]></source>
				<dl>
					<dt>id</dt>
					<dd>
						Uniquely identifies this database cluster.
					</dd>
					<dt><a href="#balancer">balancer</a></dt>
					<dd>
						Defines the balancer implementation used to distribute read operations among the active nodes of this cluster.
					</dd>
					<dt>default-sync</dt>
					<dd>
						Defines the unique identifier of the synchronization strategy to use by default when activating nodes of this cluster.
					</dd>
					<dt><a href="#dialect">dialect</a></dt>
					<dd>
						The value of this attribute defines either:
						<ul>
							<li>the class name of an implementation of the <a href="api/net/sf/hajdbc/Dialect.html">net.sf.hajdbc.Dialect</a> interface.</li>
							<li>A pre-defined alias as enumerated <a href="#dialect">here</a>.</li>
						</ul>
						HA-JDBC references the configured dialect for any vendor specific SQL.
					</dd>
					<dt>meta-data-cache</dt>
					<dd>
						Defines the strategy to use for caching database meta data.
						<dl>
							<dt>none</dt>
							<dd>Meta data is loaded when requested and not cached.</dd>
							<dt>lazy</dt>
							<dd>Meta data is loaded and cached as it is requested.</dd>
							<dt>eager</dt>
							<dd>All necessary meta data is loaded and cached during HA-JDBC initialization.</dd>
						</dl>
					</dd>
					<dt>transactions</dt>
					<dd>
						Indicates whether transactions are assumed to be single database <acronym title="Java Database Connectivity">JDBC</acronym> transactions, or distributed transactions coordinated via a transaction manager (typically provided by an application server) using the X/Open XA protocol.
						<dl>
							<dt>local</dt>
							<dd>Database writes are executed concurrently, for effiency.</dd>
							<dt>xa</dt>
							<dd>Database writes are executed synchronously, for preventing deadlocks by maintaining predictable execution order across databases.</dd>
						</dl>
					</dd>
					<dt>auto-activate-schedule</dt>
					<dd>
						Defines a cron schedule for an asynchronous task that will automatically activate any database nodes that are alive, but inactive.
						Schedule should be defined in accordance with the documentation for Quartz <a href="http://www.opensymphony.com/quartz/api/org/quartz/CronTrigger.html">CronTrigger</a>.
					</dd>
					<dt>failure-detect-schedule</dt>
					<dd>
						Defines a cron schedule for an asynchronous task that will proactively detect failed database nodes and deactivate them.
						Schedule should be defined in accordance with the documentation for Quartz <a href="http://www.opensymphony.com/quartz/api/org/quartz/CronTrigger.html">CronTrigger</a>.
					</dd>
					<dt>min-threads</dt>
					<dd>
						Defines the minimum size of the thread pool used for executing write operations.
					</dd>
					<dt>max-threads</dt>
					<dd>
						Defines the maximum size of the thread pool used for executing write operations.
					</dd>
					<dt>max-idle</dt>
					<dd>
						Defines the amount of time for which a non-core idle thread will remain in the thread pool before it is discarded.
					</dd>
				</dl>
				<section id="database">
					<title>&lt;database&gt;</title>
					<p>
						Defines the databases in this cluster that will be referenced via the java.sql.DriverManager facility.
					</p>
					<source><![CDATA[<!ELEMENT database (driver?, url, property*, (user, password)?)>]]></source>
					<dl>
						<dt>driver</dt>
						<dd>
							Defines the class name of the <acronym title="Java Database Connectivity">JDBC</acronym> driver used to access this database.
						</dd>
						<dt>url</dt>
						<dd>
							Defines the <acronym title="Java Database Connectivity">JDBC</acronym> url used to access this database.
						</dd>
						<dt><a href="#property">property</a></dt>
						<dd>
							Defines a property to be passed to the java.sql.Driver.connect() method.
						</dd>
						<dt>user</dt>
						<dd>
							Defines the user, if any, that HA-JDBC should use to connect to the database during synchronization and database failure detection.
						</dd>
						<dt>password</dt>
						<dd>
							Defines the password, if any, that HA-JDBC should use to connect to the database during synchronization and database failure detection.
						</dd>
					</dl>
					<source><![CDATA[
<!ATTLIST database
	id     CDATA #REQUIRED
	weight CDATA "1"
>
]]></source>
					<dl>
						<dt>id</dt>
						<dd>
							Unique identifer for this database node.
						</dd>
						<dt>weight</dt>
						<dd>
							Defines the relative weight of this database node.
							The weight is used by the balancer implementation to determine which node will service a read request.
						</dd>
					</dl>
				</section>
				<section id="datasource">
					<title>&lt;datasource&gt;</title>
					<p>
						Defines the databases in this cluster that will be referenced via javax.sql.DataSource.
					</p>
					<source><![CDATA[<!ELEMENT datasource (name, property*, (user, password)?>]]></source>
					<dl>
						<dt>name</dt>
						<dd>
							Defines the <acronym title="Java Naming and Directory Interface">JNDI</acronym> name of this DataSource.
						</dd>
						<dt><a href="#property">property</a></dt>
						<dd>
							Defines a <acronym title="Java Naming and Directory Interface">JNDI</acronym> environment property used when creating an InitialContext from which to lookup this DataSource.
						</dd>
						<dt>user</dt>
						<dd>
							Defines the user, if any, that HA-JDBC should use to connect to the database during synchronization and database failure detection.
						</dd>
						<dt>password</dt>
						<dd>
							Defines the password, if any, that HA-JDBC should use to connect to the database during synchronization and database failure detection.
						</dd>
					</dl>
					<source><![CDATA[
<!ATTLIST datasource
	id     CDATA #REQUIRED
	weight CDATA "1"
>
]]></source>
					<dl>
						<dt>id</dt>
						<dd>
							Unique identifer for this database node.
						</dd>
						<dt>weight</dt>
						<dd>
							Defines the relative weight of this database node.
							The weight is used by the balancer implementation to determine which node will service a read request.
						</dd>
					</dl>
				</section>
			</section>
			<section id="dialect">
				<title>Dialect</title>
				<p>
					The <code>dialect</code> attribute of a cluster determines the SQL syntax used for a given task.
					The value specified for this attribute is either the name of a class that implements <a href="api/net/sf/hajdbc/Dialect.html">net.sf.hajdbc.Dialect</a> (custom implementations are allowed), or, more conveniently, a pre-defined, case-insensitive alias.
					If the dialect attribute is omitted, then <a href="api/net/sf/hajdbc/dialect/DefaultDialect.html">net.sf.hajdbc.dialect.DefaultDialect</a> will be used.
				</p>
				<table>
					<caption>The HA-JDBC distribution contains the following dialect implementations:</caption>
					<tr>
						<th>Vendor</th>
						<th>Dialect</th>
						<th>Aliases</th>
					</tr>
					<tr>
						<td>Apache Derby</td>
						<td><a href="api/net/sf/hajdbc/dialect/DerbyDialect.html">net.sf.hajdbc.dialect.DerbyDialect</a></td>
						<td>derby</td>
					</tr>
					<tr>
						<td>Firebird</td>
						<td><a href="api/net/sf/hajdbc/dialect/FirebirdDialect.html">net.sf.hajdbc.dialect.FirebirdDialect</a></td>
						<td>firebird</td>
					</tr>
					<tr>
						<td>HSQLDB</td>
						<td><a href="api/net/sf/hajdbc/dialect/HSQLDBDialect.html">net.sf.hajdbc.dialect.HSQLDBDialect</a></td>
						<td>hsqldb</td>
					</tr>
					<tr>
						<td>IBM DB2</td>
						<td><a href="api/net/sf/hajdbc/dialect/DB2Dialect.html">net.sf.hajdbc.dialect.DB2Dialect</a></td>
						<td>db2</td>
					</tr>
					<tr>
						<td>MySQL</td>
						<td><a href="api/net/sf/hajdbc/dialect/MaxDBDialect.html">net.sf.hajdbc.dialect.MySQLDialect</a></td>
						<td>mysql</td>
					</tr>
					<tr>
						<td>MySQL MaxDB, Oracle</td>
						<td><a href="api/net/sf/hajdbc/dialect/MaxDBDialect.html">net.sf.hajdbc.dialect.MaxDBDialect</a></td>
						<td>maxdb, oracle</td>
					</tr>
					<tr>
						<td>PostgreSQL</td>
						<td><a href="api/net/sf/hajdbc/dialect/PostgreSQLDialect.html">net.sf.hajdbc.dialect.PostgreSQLDialect</a></td>
						<td>postgresql</td>
					</tr>
					<tr>
						<td>Default (SQL-92 compliant)</td>
						<td><a href="api/net/sf/hajdbc/dialect/DefaultDialect.html">net.sf.hajdbc.dialect.DefaultDialect</a></td>
						<td>ingres, mckoi</td>
					</tr>
				</table>
				<note>
					Dialect contributions are more than welcome.  Please submit any additions/updates <a href="http://sourceforge.net/tracker/?group_id=111957&amp;atid=660863">here</a>.
				</note>
			</section>
			<section id="balancer">
				<title>Balancer</title>
				<p>
					When executing a read request from the cluster, HA-JDBC uses the configured balancer strategy to determine which database should service the request.
					Each database can define a weight to affect how it is prioritized by the balancer.
					If no weight is specified for a given database, it is assumed to be 1.
				</p>
				<p>
					HA-JDBC supports four types of balancers:
				</p>
				<dl>
					<dt>simple</dt>
					<dd>
						Requests are always sent to the node with the highest weight.
					</dd>
					<dt>random</dt>
					<dd>
						Requests are sent to a random node.
						Node weights affect the probability that a given node will be chosen.
						The probability that a node will be chosen = <em>weight</em> / <em>total-weight</em>.
					</dd>
					<dt>round-robin</dt>
					<dd>
						Requests are sent to each node in succession.
						A node of weight <em>n</em> will receive <em>n</em> requests before the balancer moves on to the next node.
					</dd>
					<dt>load</dt>
					<dd>
						Requests are sent to the node with the smallest load.
						Node weights affect the calculated load of a given node.
						The load of a node = <em>concurrent-requests</em> / <em>weight</em>.
					</dd>
				</dl>
				<note>
					In general, a node with a weight of 0 will never service a request unless it is the last node in the cluster.
				</note>
			</section>
			<section id="sync-strategies">
				<title>Synchronization Strategy</title>
				<p>
					Synchronization is performed before a database node is activated.
				</p>
				<p>
					HA-JDBC provides several out-of-the-box database independent strategies for synchronizing a failed database:
				</p>
				<dl>
					<dt><a href="api/net/sf/hajdbc/sync/FullSynchronizationStrategy.html"><code>net.sf.hajdbc.sync.FullSynchronizationStrategy</code></a></dt>
					<dd>
						Each table in the inactive database is truncated and data is reinserted from an active database.
						This strategy is fastest if the database is way out of sync.
					</dd>
					<dt><a href="api/net/sf/hajdbc/sync/DifferentialSynchronizationStrategy.html"><code>net.sf.hajdbc.sync.DifferentialSynchronizationStrategy</code></a></dt>
					<dd>
						For each table in the inactive database is compared, row by row, with an active database and only changes are updated.
						This strategy is fastest if the database is more in sync than not.
					</dd>
					<dt><a href="api/net/sf/hajdbc/sync/PassiveSynchronizationStrategy.html"><code>net.sf.hajdbc.sync.PassiveSynchronizationStrategy</code></a></dt>
					<dd>
						Does nothing.
						Should only be used if databases are known to be in sync.
					</dd>
				</dl>
				<p>
					Each synchronization strategy must be defined in the HA-JDBC configuration file.
					A strategy may contain any number of JavaBean properties that can be set in the config file.
				</p>
				<p>e.g.</p>
				<source><![CDATA[
<ha-jdbc>
  <!-- ... -->
  <sync id="diff" class="net.sf.hajdbc.sync.DifferentialSynchronizationStrategy">
    <property name="fetchSize">1000</property>
  </sync>
  <sync id="full" class="net.sf.hajdbc.sync.FullSynchronizationStrategy">
    <property name="fetchSize">1000</property>
    <property name="maxBatchSize">100</property>
  </sync>
  <sync id="passive" class="net.sf.hajdbc.sync.PassiveSynchronizationStrategy"></sync>
  <!-- ... -->
</ha-jdbc>
]]></source>
				<p>
					Although the build-in strategies should be sufficient for most small databases, they are probably not feasible for large databases.
					Synchronizing a large database will typically require vendor specific functionality.
					Custom synchronization strategies may be written by implementing the <a href="api/net/sf/hajdbc/SynchronizationStrategy.html"><code>net.sf.hajdbc.SynchronizationStrategy</code></a> interface or by extending the functionality of one of the existing strategies.
					For example, I may want to improve the efficiency of the <code>FullSynchronizationStrategy</code> by dropping and re-creating indexes on my database tables.
				</p>
				<p>e.g.</p>
				<source><![CDATA[
public class FasterFullSynchronizationStrategy extends net.sf.hajdbc.sync.FullSynchronizationStrategy
{
    public void synchronize(Connection inactiveConnection, Connection activeConnection, List tableList)
    {
        // For each table, drop all indexes

        super.synchronize(inactiveConnection, activeConnection, tableList);

        // For each table, recreate all indexes
    }
}
]]></source>
				<p>
					Any custom strategies that you plan to use should also be defined in the configuration file.
				</p>
			</section>
		</section>
		<section>
			<title>Using HA-JDBC</title>
			<section>
				<title>DriverManager-based Access</title>
				<p>
					Just like your database's <acronym title="Java Database Connectivity">JDBC</acronym> driver, the HA-JDBC driver must first be loaded.
					This can be accomplished in one of two ways:
				</p>
				<ul>
					<li>
						<p>Add <code>net.sf.hajdbc.sql.Driver</code> to your <code>jdbc.drivers</code> system property.</p>
						<p>The JVM will automatically load and register each driver upon startup.</p>
					</li>
					<li>
						<p>
							Explicity load the <code>net.sf.hajdbc.sql.Driver</code> class using <code>Class.forName(...)</code>.
						</p>
						<p>
							Per the <acronym title="Java Database Connectivity">JDBC</acronym> specification, loading the HA-JDBC driver class automatically registers the driver with the <code>DriverManager</code>.
							The HA-JDBC driver will automatically load all underlying <acronym title="Java Database Connectivity">JDBC</acronym> drivers defined within a given cluster.
							This means that you do not need to perform an additional <code>Class.forName(...)</code> to load your database's driver.
						</p>
					</li>
				</ul>
				<p>e.g.</p>
				<p>
					The following is a sample HA-JDBC configuration that uses the DriverManager facility to obtain connections.
				</p>
				<source><![CDATA[
<ha-jdbc>
  <!-- ... -->
  <cluster id="cluster1" balancer="..." dialect="PostgreSQL" default-sync="...">
    <database id="database1">
      <driver>org.postgresql.Driver</driver>
      <url>jdbc:postgresql://server1/database</url>
      <user>postgres</user>
      <password>password</password>
    </datasource>
    <database id="database2">
      <driver>org.postgresql.Driver</driver>
      <url>jdbc:postgresql://server2/database</url>
      <user>postgres</user>
      <password>password</password>
    </datasource>
  </cluster>
</ha-jdbc>
]]></source>
				<p>
					The URL specified in subsequent calls to <code>DriverManager.getConnection(...)</code> follow the pattern:
				</p>
				<p><code>jdbc:ha-jdbc:</code><em>cluster-id</em></p>
				<p>e.g.</p>
				<source><![CDATA[
Connection connection = DriverManager.getConnection("jdbc:ha-jdbc:cluster1", "postgres", "password");
]]></source>
				<p>
					The following is a sample Tomcat configuration that sets up a connection pool for the above HA-JDBC database cluster.
				</p>
				<p>server.xml</p>
				<source><![CDATA[
<Context>
  <!-- ... -->
  <Resource name="jdbc/cluster" type="javax.sql.DataSource"
            username="postgres" password="password" driverClassName="net.sf.hajdbc.sql.Driver"
            url="jdbc:ha-jdbc:cluster1"/>
  <!-- ... -->
</Context>
]]></source>
				<p>web.xml</p>
				<source><![CDATA[
<web-app>
  <!-- ... -->
  <resource-env-ref>
    <resource-env-ref-name>jdbc/cluster</resource-env-ref-name>
    <resource-env-ref-type>javax.sql.DataSource</resource-env-ref-type>
  </resource-env-ref>
  <!-- ... -->
</web-app>
]]></source>
				<p>
					Pooled connections to the HA-JDBC cluster are now available via a DataSource at <code>java:comp/env/jdbc/cluster</code>.
				</p>
			</section>
			<section>
				<title>DataSource-based Access</title>
				<p>
					An HA-JDBC cluster can also wrap one or more DataSources.
				</p>
				<p>e.g.</p>
				<p>
					The following is a sample HA-JDBC configuration that uses DataSource facilities to obtain connections.
				</p>
				<source><![CDATA[
<ha-jdbc>
  <!-- ... -->
  <cluster id="cluster2" balancer="..." dialect="PostgreSQL" default-sync="...">
    <datasource id="database1">
      <name>java:comp/env/jdbc/database1</name>
    </datasource>
    <datasource id="database2">
      <name>java:comp/env/jdbc/database1</name>
    </datasource>
  </cluster>
</ha-jdbc>
]]></source>
				<p>
					The corresponding Tomcat configuration might look like the following:
				</p>
				<p>server.xml:</p>
				<source><![CDATA[
<Context>
  <!-- ... -->
  <Resource name="jdbc/cluster" factory="org.apache.naming.factory.BeanFactory"
            type="net.sf.hajdbc.sql.DataSource" cluster="cluster2"/>
  
  <Resource name="jdbc/database1" type="javax.sql.DataSource"
            username="postgres" password="password" driverClassName="org.postgresql.Driver"
            url="jdbc:postgresql://server1/database"/>

  <Resource name="jdbc/database2" type="javax.sql.DataSource"
            username="postgres" password="password" driverClassName="org.postgresql.Driver"
            url="jdbc:postgresql://server2/database"/>
  <!-- ... -->
</Context>
]]></source>
				<p>web.xml:</p>
				<source><![CDATA[
<web-app>
  <!-- ... -->
  <resource-env-ref>
    <resource-env-ref-name>jdbc/cluster</resource-env-ref-name>
    <resource-env-ref-type>javax.sql.DataSource</resource-env-ref-type>
  </resource-env-ref>
  <resource-env-ref>
    <resource-env-ref-name>jdbc/database1</resource-env-ref-name>
    <resource-env-ref-type>javax.sql.DataSource</resource-env-ref-type>
  </resource-env-ref>
  <resource-env-ref>
    <resource-env-ref-name>jdbc/database2</resource-env-ref-name>
    <resource-env-ref-type>javax.sql.DataSource</resource-env-ref-type>
  </resource-env-ref>
  <!-- ... -->
</web-app>
]]></source>
				<p>Connections are made to the HA-JDBC cluster via the following code:</p>
				<source><![CDATA[
Context context = new InitialContext();
DataSource dataSource = (DataSource) context.lookup("java:comp/env/jdbc/cluster");
Connection connection = dataSource.getConnection();
]]></source>
			</section>
			<section>
				<title>Unique identifier generation</title>
				<p>
					As of version 1.2-beta-1, HA-JDBC now supports database sequences.
					Support for auto-increment/identity columns is not yet complete, but is expected to be included in the next beta release.
				</p>
				<p>
					It is important to note the performance implications when using identity columns and sequences in conjunction with HA-JDBC.
					Both algorithms introduce per statement regular expression matching and mutex costs, the latter being particularly costly for distributed environments.
					Fortunately, the performance penalty for sequences may be improved significantly by utilizing what Hibernate calls a <a href="http://www.hibernate.org/doc/api/org/hibernate/id/SequenceHiLoGenerator.html">Sequence-HiLo algorithm</a>.
				</p>
				<p>
					For best performance, HA-JDBC recommends using a high-low or UUID algorithm so that statement parsing and locking costs can be avoided.
					Object-relation mapping (ORM) frameworks (e.g. Hibernate, OJB, Cayanne) typically include implementations of these mechanisms.
				</p>
			</section>
			<section>
				<title>Advanced <acronym title="Java Database Connectivity">JDBC</acronym> Features</title>
				<section>
					<title>Large Objects</title>
					<p>
						HA-JDBC's support for Blob and Clob objects has some limitations.
						Java 1.4 (<acronym title="Java Database Connectivity">JDBC</acronym> 3.0) introduced support for mutable Blob and Clob objects via the methods:
					</p>
					<p><code>java.sql.Blob</code>:</p>
					<ul>
						<li><code>OutputStream setOutputStream(long)</code></li>
						<li><code>int setBytes(long, byte[])</code></li>
						<li><code>int setBytes(long, byte[], int, int)</code></li>
						<li><code>void truncate(long)</code></li>
					</ul>
					<p><code>java.sql.Clob</code>:</p>
					<ul>
						<li><code>OutputStream setAsciiStream(long)</code></li>
						<li><code>Writer setCharacterStream(long)</code></li>
						<li><code>int setString(long, String)</code></li>
						<li><code>int setString(long, String, int, int)</code></li>
						<li><code>void truncate(long)</code></li>
					</ul>
					<p>
						As of version 1.1, HA-JDBC does not support these methods.
					</p>
				</section>
				<section>
					<title>RowSet Implementations</title>
					<p>
						HA-JDBC will work with any <code>javax.sql.RowSet</code> implementation provided that the rowsets use by the HA-JDBC driver.
					</p>
					<p>e.g.</p>
					<source><![CDATA[
String sql = "...";
javax.sql.RowSet rowSet = new com.sun.rowset.CachedRowSetImpl();
rowSet.setCommand(sql);
rowSet.setURL("jdbc:ha-jdbc:cluster");
rowSet.setUsername("...");
rowSet.setPassword("...");
rowSet.execute();
// ...
rowSet.close();
]]></source>
				</section>
			</section>
			<section>
				<title>Failed Database Nodes</title>
				<p>A database node may fail for any number of reasons:</p>
				<ul>
					<li>Network outage</li>
					<li>Hardware failure</li>
					<li>Operating System crash</li>
					<li>Database application crash</li>
					<li>Out of disk space</li>
					<li>No more free connections</li>
					<li>etc.</li>
				</ul>
				<p>
					Failed database nodes are detected after an SQLException is thrown when executing a given database operation.
					A database is determined to have failed if it fails to respond to a trivial query (e.g. SELECT 1).
					The query used to validate that a database is alive is defined by the configured <a href="#dialect">dialect</a>.
				</p>
				<p>
					This query may be executed manually, via the <a href="api/net/sf/hajdbc/DatabaseClusterMBean.html#isAlive(java.lang.String)"><code>isAlive(String)</code></a> method on the management interface.
				</p>
				<p>If HA-JDBC determines that a given database has failed:</p>
				<ol>
					<li>An ERROR message is logged.</li>
					<li>The database is removed from the internal registry of active databases.  No more requests will be sent to this database.</li>
					<li>If the cluster was configured to be "distributable", other servers are notified of the failure.</li>
				</ol>
				<p>
					Databases may also be manually deactivated via the <a href="#jmx"><acronym title="Java Management Extensions">JMX</acronym> management interface</a>.
				</p>
				<p>
					Optionally, you can configure HA-JDBC to proactively detect database failures via the <code>failure-detect-schedule</code> attribute.
					The value of this attribute defines a cron expression, which specifies the schedule a database cluster will detect failed databases and deactivate them.
				</p>
				<p>e.g.</p>
				<source><![CDATA[
<ha-jdbc>
  <!-- ... -->
  <!-- Failure detection will run every minute -->
  <cluster id="..." balancer="..." default-sync="..." failure-detect-schedule="0 * * ? * *">
    <!-- ... -->
  </cluster>
</ha-jdbc>
]]></source>
			</section>
			<section id="jmx">
				<title>Database Cluster Administration</title>
				<p>
					HA-JDBC database clusters are administered via a <acronym title="Java Management Extensions">JMX</acronym> interface: <a href="api/net/sf/hajdbc/DatabaseClusterMBean.html">net.sf.hajdbc.DatabaseClusterMBean</a>
				</p>
				<p>
					A database cluster mbean is registered using the following object-name:
				</p>
				<p>
					net.sf.ha-jdbc:cluster="<em>database-cluster-id</em>"
				</p>
				<p>
					<acronym title="Java Management Extensions">JMX</acronym> operations can be executed from the <a href="http://java.sun.com/j2se/1.5.0/docs/guide/management/jconsole.html">JConsole</a> interface packaged with JDK 1.5.
				</p>
				<p>
					As an alternative to JConsole (or for Java 1.4 deployments), you can use any of several 3rd-party <acronym title="Java Management Extensions">JMX</acronym> clients:
				</p>
				<ul>
					<li><a href="http://mc4j.org/">MC4J</a></li>
					<li><a href="http://www.jmanage.org/">jManage</a></li>
					<li><a href="http://ejtools.sourceforge.net/applications/jmx.browser/">EJTools JMX Browser</a></li>
					<li><a href="http://panoptesmgmt.sourceforge.net/">Panoptes</a></li>
					<li><a href="http://www.hta-bi.bfh.ch/Projects/ejbplug/">EJAM - Environment for Java Application Management</a></li>
				</ul>
				<p>
					HA-JDBC database clusters may also be administered programatically:
				</p>
				<p>e.g.</p>
				<source><![CDATA[
String clusterId = "cluster1";
String databaseId = "database1";

MBeanServer server = (MBeanServer) MBeanServerFactory.findMBeanServer(null).get(0);
ObjectName name = net.sf.hajdbc.DatabaseClusterFactory.getObjectName(clusterId);

// There are 2 ways to programatically invoke methods on an mbean:

// 1. Generic invoke
Object[] parameterValues = new Object[] { databaseId };
String[] parameterTypes = new String[] { databaseId.getClass().getName() };
server.invoke(name, "activate", parameterValues, parameterTypes);

// 2. Dynamic proxy
Object object = MBeanServerInvocationHandler.newProxyInstance(server, name, DatabaseClusterMBean.class, false);
DatabaseClusterMBean cluster = (DatabaseClusterMBean) object;
cluster.activate(databaseId);
]]></source>
				<section>
					<title>Activating a Database</title>
					<p>
						Database nodes are activated by executing one of the following methods on the database cluster mbean:
					</p>
					<dl>
						<dt><a href="api/net/sf/hajdbc/DatabaseClusterMBean.html#activate(java.lang.String)"><code>activate(String databaseId)</code></a></dt>
						<dd>Synchronizes, using the default synchronization strategy, and activates the specified database.</dd>
						<dt><a href="api/net/sf/hajdbc/DatabaseClusterMBean.html#activate(java.lang.String, java.lang.String)"><code>activate(String databaseId, String sync)</code></a></dt>
						<dd>Synchronizes, using the specified synchronization strategy, and activates the specified database.</dd>
					</dl>
					<p>
						Database synchronization is an intensive and intrusive task.
						To maintain database consistency, each database node in the cluster is read locked (i.e. writes are blocked) until synchronization completes.
						Since synchronization may take anywhere from seconds to hours (depending on the size of your database and synchronization strategy employed), if your database cluster is used in a high write volume environment, it is recommended that activation is only performed during off-peak hours.
					</p>
					<p>
						As of version 1.1, HA-JDBC includes a useful database cluster option: "auto-activate-schedule".
						If specified, HA-JDBC will automatically attempt to activate database nodes that are inactive, but alive, according to the specified cron schedule.
					</p>
					<p>e.g.</p>
					<source><![CDATA[
<ha-jdbc>
  <!-- ... -->
  <!-- Auto-activation will run every day at 2:00 AM -->
  <cluster id="..." balancer="..." default-sync="..." auto-activate-schedule="0 0 2 ? * *">
    <!-- ... -->
  </cluster>
</ha-jdbc>
]]></source>
					<note>
						In distributable mode, listening servers are automatically notified of any activated databases.
					</note>
				</section>
				<section>
					<title>Deactivating a Database</title>
					<p>
						There are a number of reasons why you might want to deactivate a database node manually - most commonly to perform some maintenance on the database or the machine itself.
						Database nodes are deactivated by executing the following method on the database cluster mbean:
					</p>
					<dl>
						<dt><a href="api/net/sf/hajdbc/DatabaseClusterMBean.html#deactivate(java.lang.String)"><code>deactivate(String databaseId)</code></a></dt>
						<dd>Deactivates the specified database.</dd>
					</dl>
					<note>
						In distributable mode, listening servers are automatically notified of any deactivated databases.
					</note>
				</section>
				<section>
					<title>Adding a Database</title>
					<p>
						In HA-JDBC 1.0, the database nodes in a cluster were static.  They could not be changed while the application/server was running.
					</p>
					<p>
						As of HA-JDBC 1.1, database nodes can be added, updated, or removed during runtime.  The cluster's JMX interface includes the following methods:
					</p>
					<dl>
						<dt><a href="api/net/sf/hajdbc/DatabaseClusterMBean.html#add(java.lang.String, java.lang.String, java.lang.String)"><code>add(String databaseId, String driver, String url)</code></a></dt>
						<dd>Adds a new JDBC url-based database to the cluster.</dd>
						<dt><a href="api/net/sf/hajdbc/DatabaseClusterMBean.html#add(java.lang.String, java.lang.String)"><code>add(String databaseId, String name)</code></a></dt>
						<dd>Adds a new DataSource-based database cluster.</dd>
						<dt><a href="api/net/sf/hajdbc/DatabaseClusterMBean.html#remove(java.lang.String)"><code>remove(String databaseId)</code></a></dt>
						<dd>Removes a database node from the cluster.</dd>
					</dl>
					<p>
						When a new database is added, it is initially inactive.
						Database nodes may also be removed from the cluster.
						A database node must first by inactive before it can be removed.
					</p>
					<p>
						HA-JDBC 1.1 also adds mbean interfaces for individual database nodes:
					</p>
					<ul>
						<li><a href="api/net/sf/hajdbc/sql/InactiveDriverDatabaseMBean.html"><code>net.sf.hajdbc.sql.InactiveDriverDatabaseMBean</code></a></li>
						<li><a href="api/net/sf/hajdbc/sql/InactiveDataSourceDatabaseMBean.html"><code>net.sf.hajdbc.sql.InactiveDataSourceDatabaseMBean</code></a></li>
						<li><a href="api/net/sf/hajdbc/sql/ActiveDriverDatabaseMBean.html"><code>net.sf.hajdbc.sql.ActiveDriverDatabaseMBean</code></a></li>
						<li><a href="api/net/sf/hajdbc/sql/ActiveDataSourceDatabaseMBean.html"><code>net.sf.hajdbc.sql.ActiveDataSourceDatabaseMBean</code></a></li>
					</ul>
					<p>
						Database mbeans are registered using the following object-name:
					</p>
					<p>
						net.sf.ha-jdbc:cluster="<em>cluster-id</em>",database="<em>database-id</em>"
					</p>
					<p>
						While inactive, a database node's connection properties (e.g. user, password, etc.) may be modified.
						When active, a database node's connection properties are read-only.
					</p>
					<p>
						When a database node is activated and it's configuration has changed, or when a database node is removed, the configuration is saved to it's original URL.
					</p>
					<warning>
						In distributable mode, listening servers are <em>not</em> notified of database node additions, updates, and removals.
						These cluster modifications must be made on each server.
					</warning>
				</section>
			</section>
		</section>
	</body>
</document>
